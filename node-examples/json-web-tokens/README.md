# JSON Web Tokens

JSON Web Tokens (JWT) are an open standard (RFC 7519) used for securely transmitting information between parties as a JSON object. This information can be verified and trusted because it is digitally signed. JWTs can be signed using a secret (with the HMAC algorithm) or a public/private key pair using RSA or ECDSA.

A JWT typically consists of three parts: Header, Payload, and Signature. Let's break down each part using the example you provided:


Example JWT:

```
eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJhdWRpZW5jZSI6IkNJUzQ4NSIsInByaXZpbGVnZSI6InJlYWQiLCJpYXQiOjE3MTEwNTgyOTUsImV4cCI6MTcxMTA2MTg5NX0.FvTUn6mDhrckUfUejRGf-gyVE4F3LFchVl2aXyKyav0
```

1. Header

The Header typically consists of two parts: the type of the token (typ), which is JWT, and the signing algorithm being used (alg), such as HMAC SHA256 or RSA.

Example Header Decoded:

```
{
  "alg": "HS256",
  "typ": "JWT"
}
```

2. Payload

The Payload part of the token contains the claims. Claims are statements about an entity (typically, the user) and additional data. There are three types of claims: registered, public, and private claims.

Example Payload Decoded:

```
{
  "audience": "CIS485",
  "privilege": "read",
  "iat": 1711058295,
  "exp": 1711061895
}
```

audience: Identifies the recipients that the JWT is intended for.
privilege: Custom claim added to provide specific privileges to the user.
iat (Issued At): Time at which the JWT was issued.
exp (Expiration Time): Time at which the JWT expires.

3. Signature

The Signature is used to secure and verify that the token has not been altered. It is generated by taking the encoded header, the encoded payload, a secret, the algorithm specified in the header, and signing that.

Example Signature Process:

```
HMACSHA256(
  base64UrlEncode(header) + "." + base64UrlEncode(payload),
  secret)
```

### How the Secret is Used to Verify the Token

The secret is used in the Signature part of the JWT. When the token is created, the signature is generated using the header and payload, combined with the secret, using the algorithm specified in the header. This signature ensures that the token is not tampered with.

To verify a JWT, the receiving party takes the header and payload from the token, uses the same algorithm and secret to generate a signature, and then compares it with the signature part of the token. If they match, the token is considered valid and untampered. Since only the party that issued the token and anyone with the secret can generate a valid signature, this verifies that the token is authentic and was issued by a trusted party.

The secret is crucial for the security of JWTs when using symmetric algorithms like HMAC. In cases where asymmetric algorithms are used, a public key can verify the signature instead of a shared secret, enhancing security by not requiring the secret to be distributed.
